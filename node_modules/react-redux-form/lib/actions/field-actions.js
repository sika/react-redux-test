'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _get2 = require('../utils/get');

var _get3 = _interopRequireDefault(_get2);

var _mapValues = require('../utils/map-values');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _actionTypes = require('../action-types');

var _actionTypes2 = _interopRequireDefault(_actionTypes);

var _batchActions = require('./batch-actions');

var _batchActions2 = _interopRequireDefault(_batchActions);

var _getValidity = require('../utils/get-validity');

var _getValidity2 = _interopRequireDefault(_getValidity);

var _isValidityValid = require('../utils/is-validity-valid');

var _isValidityValid2 = _interopRequireDefault(_isValidityValid);

var _isValidityInvalid = require('../utils/is-validity-invalid');

var _isValidityInvalid2 = _interopRequireDefault(_isValidityInvalid);

var _invertValidity = require('../utils/invert-validity');

var _invertValidity2 = _interopRequireDefault(_invertValidity);

var _track = require('../utils/track');

var _getForm = require('../utils/get-form');

var _getForm2 = _interopRequireDefault(_getForm);

var _isValid = require('../form/is-valid');

var _isValid2 = _interopRequireDefault(_isValid);

var _nullAction = require('../constants/null-action');

var _nullAction2 = _interopRequireDefault(_nullAction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var focus = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.FOCUS,
    model: model
  };
});

var blur = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.BLUR,
    model: model
  };
});

var setPristine = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_PRISTINE,
    model: model
  };
});

var setDirty = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_DIRTY,
    model: model
  };
});

var setInitial = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_INITIAL,
    model: model
  };
});

var setPending = (0, _track.trackable)(function (model) {
  var pending = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_PENDING,
    model: model,
    pending: pending
  };
});

var setValidating = (0, _track.trackable)(function (model) {
  var validating = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_VALIDATING,
    model: model,
    validating: validating
  };
});

var setValidity = (0, _track.trackable)(function (model, validity) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _defineProperty({
    type: options.errors ? _actionTypes2.default.SET_ERRORS : _actionTypes2.default.SET_VALIDITY,
    model: model
  }, options.errors ? 'errors' : 'validity', validity);
});

var setFieldsValidity = (0, _track.trackable)(function (model, fieldsValidity) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return {
    type: _actionTypes2.default.SET_FIELDS_VALIDITY,
    model: model,
    fieldsValidity: fieldsValidity,
    options: options
  };
});

var setErrors = (0, _track.trackable)(function (model, errors) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return setValidity(model, errors, _extends({}, options, {
    errors: true
  }));
});

var setFieldsErrors = (0, _track.trackable)(function (model, fieldsErrors, options) {
  return setFieldsValidity(model, fieldsErrors, _extends({}, options, {
    errors: true
  }));
});

var resetValidity = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.RESET_VALIDITY,
    model: model
  };
});

var resetErrors = resetValidity;

var setTouched = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_TOUCHED,
    model: model
  };
});

var setUntouched = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_UNTOUCHED,
    model: model
  };
});

var asyncSetValidity = (0, _track.trackable)(function (model, validator) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);

    dispatch(setValidating(model, true));

    var done = function done(validity) {
      dispatch(setValidity(model, validity));
    };

    var immediateResult = validator(value, done);

    if (typeof immediateResult !== 'undefined') {
      done(immediateResult);
    }
  };
});

var setSubmitted = (0, _track.trackable)(function (model) {
  var submitted = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_SUBMITTED,
    model: model,
    submitted: submitted
  };
});

var setSubmitFailed = (0, _track.trackable)(function (model) {
  var submitFailed = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_SUBMIT_FAILED,
    model: model,
    submitFailed: submitFailed
  };
});

var submit = (0, _track.trackable)(function (model, promise) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return function (dispatch, getState) {
    if (options.validate) {
      var form = (0, _getForm2.default)(getState(), model);

      if (!form.$form.valid) {
        return dispatch(_nullAction2.default);
      }

      dispatch(setPending(model, true));
    } else if (options.validators || options.errors) {
      var validators = options.validators || options.errors;
      var isErrors = options.errors;
      var value = (0, _get3.default)(getState(), model);
      var validity = (0, _getValidity2.default)(validators, value);
      var valid = options.errors ? !(0, _isValidityInvalid2.default)(validity) : (0, _isValidityValid2.default)(validity);

      if (!valid) {
        return dispatch(isErrors ? setErrors(model, validity) : setValidity(model, validity));
      }

      dispatch((0, _batchActions2.default)(model, [setValidity(model, isErrors ? (0, _invertValidity2.default)(validity) : validity), setPending(model, true)]));
    } else {
      dispatch(setPending(model, true));
    }

    var errorsAction = options.fields ? setFieldsErrors : setErrors;

    promise.then(function (response) {
      dispatch((0, _batchActions2.default)(model, [setSubmitted(model, true), setValidity(model, response)]));
    }).catch(function (error) {
      console.error(error);
      dispatch((0, _batchActions2.default)(model, [setSubmitFailed(model), errorsAction(model, error)]));
    });

    return promise;
  };
});

var submitFields = function submitFields(model, promise) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return submit(model, promise, _extends({}, options, {
    fields: true
  }));
};

var validSubmit = function validSubmit(model, promise) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return submit(model, promise, _extends({}, options, {
    validate: true
  }));
};

var validate = (0, _track.trackable)(function (model, validators) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);
    var validity = (0, _getValidity2.default)(validators, value);

    dispatch(setValidity(model, validity));
  };
});

var validateErrors = (0, _track.trackable)(function (model, errorValidators) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);
    var errors = (0, _getValidity2.default)(errorValidators, value);

    dispatch(setValidity(model, errors, { errors: true }));
  };
});

function isFormValidWithoutFields(form, fieldsValidity) {
  if (Object.keys(form.$form.validity).length && !(0, _isValidityValid2.default)(form.$form.validity)) {
    return false;
  }

  // TODO: map through form keys without $form
  var valid = Object.keys(form).every(function (fieldKey) {
    if (fieldKey === '$form') return true;

    if (fieldsValidity.hasOwnProperty(fieldKey)) {
      return true;
    }

    return (0, _isValid2.default)(form[fieldKey]);
  });

  return valid;
}

var validateFields = (0, _track.trackable)(function (model, fieldValidators) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);

    var fieldsValidity = (0, _mapValues2.default)(fieldValidators, function (validator, field) {
      var fieldValue = field ? (0, _get3.default)(value, field) : value;

      var fieldValidity = (0, _getValidity2.default)(validator, fieldValue);

      return fieldValidity;
    });

    var validCB = options.onValid;
    var invalidCB = options.onInvalid;

    if (validCB || invalidCB) {
      var form = (0, _getForm2.default)(getState(), model);
      var formValid = form && !fieldsValidity.hasOwnProperty('') ? isFormValidWithoutFields(form, fieldsValidity) : true;

      var fieldsValid = options.errors ? !(0, _isValidityInvalid2.default)(fieldsValidity) : (0, _isValidityValid2.default)(fieldsValidity);

      if (validCB && formValid && fieldsValid) {
        validCB();
      } else if (invalidCB) {
        invalidCB();
      }
    }

    var fieldsValiditySetter = options.errors ? setFieldsErrors : setFieldsValidity;

    dispatch(fieldsValiditySetter(model, fieldsValidity));
  };
});

var validateFieldsErrors = (0, _track.trackable)(function (model, fieldErrorsValidators) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return validateFields(model, fieldErrorsValidators, _extends({}, options, {
    errors: true
  }));
});

exports.default = {
  blur: blur,
  focus: focus,
  submit: submit,
  submitFields: submitFields,
  validSubmit: validSubmit,
  setDirty: setDirty,
  setErrors: setErrors,
  setInitial: setInitial,
  setPending: setPending,
  setValidating: setValidating,
  setPristine: setPristine,
  setSubmitted: setSubmitted,
  setSubmitFailed: setSubmitFailed,
  setTouched: setTouched,
  setUntouched: setUntouched,
  setValidity: setValidity,
  setFieldsValidity: setFieldsValidity,
  setFieldsErrors: setFieldsErrors,
  resetValidity: resetValidity,
  resetErrors: resetErrors,
  validate: validate,
  validateErrors: validateErrors,
  validateFields: validateFields,
  validateFieldsErrors: validateFieldsErrors,
  asyncSetValidity: asyncSetValidity
};
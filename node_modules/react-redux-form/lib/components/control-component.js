'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactRedux = require('react-redux');

var _redux = require('redux');

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

var _shallowEqual = require('../utils/shallow-equal');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _get2 = require('../utils/get');

var _get3 = _interopRequireDefault(_get2);

var _merge = require('../utils/merge');

var _merge2 = _interopRequireDefault(_merge);

var _mapValues = require('../utils/map-values');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _icepick = require('icepick');

var _icepick2 = _interopRequireDefault(_icepick);

var _omit = require('lodash/omit');

var _omit2 = _interopRequireDefault(_omit);

var _handleFocus = require('../utils/handle-focus');

var _handleFocus2 = _interopRequireDefault(_handleFocus);

var _getValue = require('../utils/get-value');

var _getValue2 = _interopRequireDefault(_getValue);

var _getValidity = require('../utils/get-validity');

var _getValidity2 = _interopRequireDefault(_getValidity);

var _invertValidity = require('../utils/invert-validity');

var _invertValidity2 = _interopRequireDefault(_invertValidity);

var _getFieldFromState = require('../utils/get-field-from-state');

var _getFieldFromState2 = _interopRequireDefault(_getFieldFromState);

var _getModel = require('../utils/get-model');

var _getModel2 = _interopRequireDefault(_getModel);

var _persistEventWithCallback = require('../utils/persist-event-with-callback');

var _persistEventWithCallback2 = _interopRequireDefault(_persistEventWithCallback);

var _actions = require('../actions');

var _actions2 = _interopRequireDefault(_actions);

var _controlPropsMap = require('../constants/control-props-map');

var _controlPropsMap2 = _interopRequireDefault(_controlPropsMap);

var _validityKeys = require('../constants/validity-keys');

var _validityKeys2 = _interopRequireDefault(_validityKeys);

var _batchActions = require('../actions/batch-actions');

var _resolveModel = require('../utils/resolve-model');

var _resolveModel2 = _interopRequireDefault(_resolveModel);

var _isNative = require('../utils/is-native');

var _isNative2 = _interopRequireDefault(_isNative);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var findDOMNode = !_isNative2.default ? require('react-dom').findDOMNode : null;

function containsEvent(events, event) {
  if (typeof events === 'string') {
    return events === event;
  }

  return !!~events.indexOf(event);
}

var propTypes = {
  model: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.string]).isRequired,
  modelValue: _react.PropTypes.any,
  viewValue: _react.PropTypes.any,
  control: _react.PropTypes.any,
  onLoad: _react.PropTypes.func,
  onSubmit: _react.PropTypes.func,
  fieldValue: _react.PropTypes.object,
  mapProps: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object]),
  changeAction: _react.PropTypes.func,
  updateOn: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.string), _react.PropTypes.string]),
  validateOn: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.string), _react.PropTypes.string]),
  validators: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object]),
  asyncValidateOn: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.string), _react.PropTypes.string]),
  asyncValidators: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object]),
  errors: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object]),
  controlProps: _react.PropTypes.object,
  component: _react.PropTypes.any,
  dispatch: _react.PropTypes.func,
  parser: _react.PropTypes.func,
  getter: _react.PropTypes.func,
  ignore: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.string), _react.PropTypes.string]),
  dynamic: _react.PropTypes.bool
};

function mapStateToProps(state, props) {
  var model = props.model;
  var _props$getter = props.getter;
  var getter = _props$getter === undefined ? _get3.default : _props$getter;
  var _props$controlProps = props.controlProps;
  var controlProps = _props$controlProps === undefined ? (0, _omit2.default)(props, Object.keys(propTypes)) : _props$controlProps;


  var modelString = (0, _getModel2.default)(model, state);
  var fieldValue = (0, _getFieldFromState2.default)(state, modelString);

  return {
    model: modelString,
    modelValue: getter(state, modelString),
    fieldValue: fieldValue,
    controlProps: controlProps
  };
}

function isReadOnlyValue(controlProps) {
  return ~['radio', 'checkbox'].indexOf(controlProps.type);
}

var emptyControlProps = {};

var Control = function (_Component) {
  _inherits(Control, _Component);

  function Control(props) {
    _classCallCheck(this, Control);

    var _this = _possibleConstructorReturn(this, (Control.__proto__ || Object.getPrototypeOf(Control)).call(this, props));

    _this.getChangeAction = _this.getChangeAction.bind(_this);
    _this.getValidateAction = _this.getValidateAction.bind(_this);

    _this.handleKeyPress = _this.handleKeyPress.bind(_this);
    _this.createEventHandler = _this.createEventHandler.bind(_this);
    _this.handleFocus = _this.createEventHandler('focus').bind(_this);
    _this.handleBlur = _this.createEventHandler('blur').bind(_this);
    _this.handleUpdate = _this.createEventHandler('change').bind(_this);
    _this.handleChange = _this.handleChange.bind(_this);
    _this.handleLoad = _this.handleLoad.bind(_this);
    _this.getMappedProps = _this.getMappedProps.bind(_this);
    _this.attachNode = _this.attachNode.bind(_this);

    _this.state = {
      viewValue: props.modelValue
    };
    return _this;
  }

  _createClass(Control, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.attachNode();
      this.handleLoad();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var modelValue = nextProps.modelValue;


      if (modelValue !== this.props.modelValue) {
        this.setViewValue(modelValue, nextProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      var result = !(0, _shallowEqual2.default)(this.props, nextProps, ['controlProps']) || !(0, _shallowEqual2.default)(this.props.controlProps, nextProps.controlProps) || !(0, _shallowEqual2.default)(this.state.viewValue, nextState.viewValue);

      return result;
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props;
      var modelValue = _props.modelValue;
      var fieldValue = _props.fieldValue;
      var updateOn = _props.updateOn;
      var _props$validateOn = _props.validateOn;
      var validateOn = _props$validateOn === undefined ? updateOn : _props$validateOn;
      var validators = _props.validators;
      var errors = _props.errors;


      if ((validators || errors) && fieldValue && !fieldValue.validated && modelValue !== prevProps.modelValue && validateOn === 'change') {
        this.validate();
      }

      // Manually focus/blur node
      (0, _handleFocus2.default)(fieldValue, this.node);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var _props2 = this.props;
      var model = _props2.model;
      var fieldValue = _props2.fieldValue;
      var dispatch = _props2.dispatch;
      var _props2$validators = _props2.validators;
      var validators = _props2$validators === undefined ? {} : _props2$validators;
      var _props2$errors = _props2.errors;
      var errors = _props2$errors === undefined ? {} : _props2$errors;


      if (!fieldValue) return;

      if (!fieldValue.valid) {
        var keys = Object.keys(validators).concat(Object.keys(errors));

        dispatch(_actions2.default.setValidity(model, (0, _omit2.default)(fieldValue.validity, keys)));
      }
    }
  }, {
    key: 'getMappedProps',
    value: function getMappedProps() {
      var props = this.props;
      var mapProps = props.mapProps;
      var viewValue = this.state.viewValue;

      var originalProps = _extends({}, props, props.controlProps, {
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onChange: this.handleChange,
        onKeyPress: this.handleKeyPress,
        viewValue: viewValue
      });

      if ((0, _isPlainObject2.default)(mapProps)) {
        return _icepick2.default.merge(originalProps, (0, _mapValues2.default)(mapProps, function (value, key) {
          if (typeof value === 'function' && key !== 'component') {
            return value(originalProps);
          }

          return value;
        }));
      }

      return mapProps(originalProps);
    }
  }, {
    key: 'getChangeAction',
    value: function getChangeAction(event) {
      var _props3 = this.props;
      var model = _props3.model;
      var controlProps = _props3.controlProps;

      var _getMappedProps = this.getMappedProps();

      var _getMappedProps$chang = _getMappedProps.changeAction;
      var changeAction = _getMappedProps$chang === undefined ? _actions2.default.change : _getMappedProps$chang;

      var value = isReadOnlyValue(controlProps) ? controlProps.value : event;

      return changeAction(model, (0, _getValue2.default)(value));
    }
  }, {
    key: 'getValidateAction',
    value: function getValidateAction(value) {
      var _props4 = this.props;
      var validators = _props4.validators;
      var errors = _props4.errors;
      var model = _props4.model;
      var fieldValue = _props4.fieldValue;


      var nodeErrors = this.getNodeErrors();

      if (validators || errors) {
        var fieldValidity = (0, _getValidity2.default)(validators, value);
        var fieldErrors = (0, _merge2.default)((0, _getValidity2.default)(errors, value), nodeErrors);

        var mergedErrors = validators ? (0, _merge2.default)((0, _invertValidity2.default)(fieldValidity), fieldErrors) : fieldErrors;

        if (!fieldValue || !(0, _shallowEqual2.default)(mergedErrors, fieldValue.errors)) {
          return _actions2.default.setErrors(model, mergedErrors);
        }
      } else if (nodeErrors && Object.keys(nodeErrors).length) {
        return _actions2.default.setErrors(model, nodeErrors);
      }

      return false;
    }
  }, {
    key: 'getAsyncValidateAction',
    value: function getAsyncValidateAction(value) {
      var _props5 = this.props;
      var asyncValidators = _props5.asyncValidators;
      var fieldValue = _props5.fieldValue;
      var model = _props5.model;

      // If there are no async validators,
      // do not run async validation

      if (!asyncValidators) return false;

      // If any sync validity is invalid,
      // do not run async validation
      var asyncValidatorKeys = Object.keys(asyncValidators);
      var syncValid = Object.keys(fieldValue.validity).every(function (key) {
        // If validity is based on async validator, skip
        if (!!~asyncValidatorKeys.indexOf(key)) return true;

        return fieldValue.validity[key];
      });

      if (!syncValid) return false;

      return function (dispatch) {
        (0, _mapValues2.default)(asyncValidators, function (validator, key) {
          return dispatch(_actions2.default.asyncSetValidity(model, function (_, done) {
            var outerDone = function outerDone(valid) {
              var validity = _icepick2.default.merge(fieldValue.validity, _defineProperty({}, key, valid));

              done(validity);
            };

            validator((0, _getValue2.default)(value), outerDone);
          }));
        });

        return value;
      };
    }
  }, {
    key: 'getNodeErrors',
    value: function getNodeErrors() {
      var node = this.node;
      var fieldValue = this.props.fieldValue;


      if (!node || !node.willValidate) {
        return null;
      }

      var nodeErrors = {};

      _validityKeys2.default.forEach(function (key) {
        var errorValidity = node.validity[key];

        // If the key is invalid or they key was
        // previously invalid and is now valid,
        // set its validity
        if (errorValidity || fieldValue && fieldValue.errors[key]) {
          nodeErrors[key] = errorValidity;
        }
      });

      return nodeErrors;
    }
  }, {
    key: 'setViewValue',
    value: function setViewValue(viewValue) {
      var props = arguments.length <= 1 || arguments[1] === undefined ? this.props : arguments[1];

      if (!isReadOnlyValue(props.controlProps)) {
        this.setState({ viewValue: viewValue });
      }
    }
  }, {
    key: 'handleChange',
    value: function handleChange(event) {
      this.setViewValue((0, _getValue2.default)(event));
      this.handleUpdate(event);
    }
  }, {
    key: 'handleKeyPress',
    value: function handleKeyPress(event) {
      if (event.key === 'Enter') {
        this.handleSubmit(event);
      }
    }
  }, {
    key: 'handleLoad',
    value: function handleLoad() {
      var _props6 = this.props;
      var model = _props6.model;
      var modelValue = _props6.modelValue;
      var fieldValue = _props6.fieldValue;
      var _props6$controlProps = _props6.controlProps;
      var controlProps = _props6$controlProps === undefined ? emptyControlProps : _props6$controlProps;
      var onLoad = _props6.onLoad;
      var dispatch = _props6.dispatch;
      var changeAction = _props6.changeAction;
      var parser = _props6.parser;

      var loadActions = [];
      var defaultValue = undefined;

      if (controlProps.hasOwnProperty('defaultValue')) {
        defaultValue = controlProps.defaultValue;
      } else if (controlProps.hasOwnProperty('defaultChecked')) {
        defaultValue = controlProps.defaultChecked;
      }

      if (typeof defaultValue !== 'undefined') {
        loadActions.push(this.getValidateAction(defaultValue));
        loadActions.push(changeAction(model, defaultValue));
      } else {
        loadActions.push(this.getValidateAction(modelValue));

        if (parser) {
          var parsedValue = parser(modelValue);

          if (parsedValue !== modelValue) {
            loadActions.push(changeAction(model, parsedValue));
          }
        }
      }

      (0, _batchActions.dispatchBatchIfNeeded)(model, loadActions, dispatch);

      if (onLoad) onLoad(modelValue, fieldValue, this.node);
    }
  }, {
    key: 'handleSubmit',
    value: function handleSubmit(event) {
      var dispatch = this.props.dispatch;


      dispatch(this.getChangeAction(event));
    }
  }, {
    key: 'createEventHandler',
    value: function createEventHandler(eventName) {
      var _this2 = this;

      var _props7 = this.props;
      var dispatch = _props7.dispatch;
      var model = _props7.model;
      var updateOn = _props7.updateOn;
      var _props7$validateOn = _props7.validateOn;
      var validateOn = _props7$validateOn === undefined ? updateOn : _props7$validateOn;
      var asyncValidateOn = _props7.asyncValidateOn;
      var _props7$controlProps = _props7.controlProps;
      var controlProps = _props7$controlProps === undefined ? emptyControlProps : _props7$controlProps;
      var parser = _props7.parser;
      var ignore = _props7.ignore;


      var eventAction = {
        focus: _actions2.default.focus,
        blur: _actions2.default.blur
      }[eventName];

      var controlEventHandler = {
        focus: controlProps.onFocus,
        blur: controlProps.onBlur,
        change: controlProps.onChange
      }[eventName];

      var dispatchBatchActions = function dispatchBatchActions(persistedEvent) {
        var eventActions = eventAction ? [eventAction(model)] : [];

        if (containsEvent(validateOn, eventName)) {
          eventActions.push(_this2.getValidateAction(persistedEvent));
        }

        if (containsEvent(asyncValidateOn, eventName)) {
          eventActions.push(_this2.getAsyncValidateAction(persistedEvent));
        }

        if (containsEvent(updateOn, eventName)) {
          eventActions.push(_this2.getChangeAction(persistedEvent));
        }

        (0, _batchActions.dispatchBatchIfNeeded)(model, eventActions, dispatch);

        return persistedEvent;
      };

      return function (event) {
        if (containsEvent(ignore, eventName)) {
          return controlEventHandler ? controlEventHandler(event) : event;
        }

        if (isReadOnlyValue(controlProps)) {
          return (0, _redux.compose)(dispatchBatchActions, (0, _persistEventWithCallback2.default)(controlEventHandler || _identity2.default))(event);
        }

        return (0, _redux.compose)(dispatchBatchActions, parser, _getValue2.default, (0, _persistEventWithCallback2.default)(controlEventHandler || _identity2.default))(event);
      };
    }
  }, {
    key: 'attachNode',
    value: function attachNode() {
      if (!findDOMNode) return;

      var node = findDOMNode(this);

      if (node) this.node = node;
    }
  }, {
    key: 'validate',
    value: function validate() {
      var _props8 = this.props;
      var model = _props8.model;
      var modelValue = _props8.modelValue;
      var fieldValue = _props8.fieldValue;
      var validators = _props8.validators;
      var errorValidators = _props8.errors;
      var dispatch = _props8.dispatch;


      if (!validators && !errorValidators) return modelValue;

      var fieldValidity = (0, _getValidity2.default)(validators, modelValue);
      var fieldErrors = (0, _getValidity2.default)(errorValidators, modelValue);

      var errors = validators ? (0, _merge2.default)((0, _invertValidity2.default)(fieldValidity), fieldErrors) : fieldErrors;

      if (!(0, _shallowEqual2.default)(errors, fieldValue.errors)) {
        dispatch(_actions2.default.setErrors(model, errors));
      }

      return modelValue;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props9 = this.props;
      var _props9$controlProps = _props9.controlProps;
      var controlProps = _props9$controlProps === undefined ? emptyControlProps : _props9$controlProps;
      var component = _props9.component;
      var control = _props9.control;


      var mappedProps = this.getMappedProps();

      var allowedProps = (0, _omit2.default)(mappedProps, Object.keys(propTypes));

      // If there is an existing control, clone it
      if (control) {
        return (0, _react.cloneElement)(control, _extends({}, allowedProps, {
          onKeyPress: this.handleKeyPress
        }), controlProps.children);
      }

      return (0, _react.createElement)(component, _extends({}, controlProps, allowedProps, {
        onKeyPress: this.handleKeyPress
      }), controlProps.children);
    }
  }]);

  return Control;
}(_react.Component);

if (process.env.NODE_ENV !== 'production') {
  Control.propTypes = propTypes;
}

Control.defaultProps = {
  changeAction: _actions2.default.change,
  updateOn: 'change',
  asyncValidateOn: 'blur',
  parser: _identity2.default,
  controlProps: emptyControlProps,
  getter: _get3.default,
  ignore: [],
  dynamic: false,
  mapProps: _controlPropsMap2.default.default,
  component: 'input'
};

var ConnectedControl = (0, _resolveModel2.default)((0, _reactRedux.connect)(mapStateToProps)(Control));

/* eslint-disable react/prop-types */
ConnectedControl.input = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'input',
    mapProps: _extends({}, _controlPropsMap2.default.default, props.mapProps)
  }, props));
};

ConnectedControl.text = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'input',
    mapProps: _extends({}, _controlPropsMap2.default.text, props.mapProps)
  }, props));
};

ConnectedControl.textarea = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'textarea',
    mapProps: _extends({}, _controlPropsMap2.default.textarea, props.mapProps)
  }, props));
};

ConnectedControl.radio = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'input',
    type: 'radio',
    mapProps: _extends({}, _controlPropsMap2.default.radio, props.mapProps)
  }, props));
};

ConnectedControl.checkbox = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'input',
    type: 'checkbox',
    mapProps: _extends({}, _controlPropsMap2.default.checkbox, props.mapProps)
  }, props));
};

ConnectedControl.file = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'input',
    type: 'file',
    mapProps: _extends({}, _controlPropsMap2.default.file, props.mapProps)
  }, props));
};

ConnectedControl.select = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'select',
    mapProps: _extends({}, _controlPropsMap2.default.select, props.mapProps)
  }, props));
};

ConnectedControl.reset = function (props) {
  return _react2.default.createElement(ConnectedControl, _extends({
    component: 'button',
    type: 'reset',
    mapProps: _extends({}, _controlPropsMap2.default.reset, props.mapProps)
  }, props));
};

exports.default = ConnectedControl;